#' Compare R Objects with a Text Diff
#'
#' Highlights differences between R objects in a familiar and intuitive way.
#' This is similar to \code{\link{tools::Rdiff}} except the diff is computed
#' directly on R objects instead of text files, does not rely on the system
#' \code{diff} utility, and provides alternate display modes.
#'
#' @import crayon
#' @name diffobj-package
#' @docType package

NULL

# Because all these functions are so similar, we have construct them with a
# function factory.  This allows us to easily maintain consisten formals during
# initial development process when they have not been set in stone yet.

make_diff_fun <- function(capt_fun) {
  function(
    target, current, mode=getOption("diffobj.mode"),
    context=getOption("diffobj.context"), etc=NULL, ...
  ) {
    etc.val <- if(is.null(etc)) etc() else etc  # resolve recursive default arg

    # Force evaluation of dots to make sure user doesn't mess us up with
    # something like options(crayon.enabled=...)

    dots <- list(...)

    # Check args

    etc.proc <- check_args(
      call=call, tar.exp=substitute(target), cur.exp=substitute(current),
      mode=mode, context=context, etc=etc.val
    )
    # Force crayon to whatever ansi status we chose; note we must do this after
    # touching vars in case someone passes `options(crayon.enabled=...)` as one
    # of the arguments

    old.crayon.opt <- options(crayon.enabled=etc.proc@use.ansi)
    on.exit(options(old.crayon.opt), add=TRUE)
    err <- make_err_fun(sys.call())
    capt_fun(target, current, etc=etc.proc, err=err, ...)
  }
}
#' Diff \code{print}ed Objects
#'
#' Runs the diff between the \code{print} or \code{show} output produced by
#' two objects.  If the objects are both normal atomic vectors, the function
#' will recognize the wrapped printed output and will carry out the diff
#' element by element rather than line by line.  The \code{+-} diff indicators
#' in the gutters will still reference the line diffs, but additionally the
#' element by element matches and differences will be highlighted by word diff
#' markers.
#'
#' @export
#' @param target the reference object
#' @param current the object being compared to \code{target}
#' @param mode character(1L), one of:
#'   \itemize{
#'     \item unified: diff mode used by \code{git diff}, and the default here
#'     \item sidebyside: line up the differences side by side
#'     \item context: show the target and current hunks in their entirety; this
#'       mode takes up a lot of screen space but makes it easier to see what the
#'       objects actually look like
#'   }
#' @param context integer(1L) how many lines of context are shown on either side
#'   of differences, set to \code{-1L} to allow as many as there are.  Set to
#'   \dQuote{auto} (default) to display as many as 10 lines or as few as 1
#'   depending on whether total screen lines fit within \code{line.limit} (see
#'   \code{\link{etc}}), or alternatively pass the return value of
#'   \code{\link{auto_context}} to fine tune the parameters of the auto context
#'   calculation.
#' @param etc diffObjSettings S4 object as generated by \code{\link{etc}},
#'   allows control of parameters such as whether to truncate output, use a
#'   pager, ignore white space differences, color output, etc.  See
#'   documentation for \code{\link{etc}} for more details.  If NULL (default)
#'   equivalent to passing \code{etc()}
#' @param ... additional arguments to pass on to \code{print}, \code{str}, etc.
#' @seealso \code{\link{diff_obj}} for details on output and diff algorithm,
#'   \code{\link{etc}} for more detailed control of diff settings,
#'   \code{\link{diff_str}},
#'   \code{\link{diff_chr}} to compare character vectors directly,
#'   \code{\link{diff_deparse}} to compare deparsed objects
#' @return a \code{\link{diffObjDiff}} object; this object has a \code{show}
#'   method that will display the diff to screen
#' @export

diff_print <- make_diff_fun(capt_print)

#' Diff Object Structures
#'
#' Compares the \code{str} output of \code{target} and \code{current}.  If
#' the \code{max.level} parameter to \code{str} is left unspecified, will
#' attempt to find the largest \code{max.level} that fits within
#' \code{line.limit} (see \code{\link{etc}}) and shows at least one difference.
#'
#' Due to the seemingly inconsistent nature of \code{max.level} when used with
#' objects with nested attributes, and also due to the relative slowness of
#' \code{str}, this function simulates the effect of \code{max.level} by hiding
#' nested lines instead of repeatedly calling \code{str} with varying values of
#' \code{max.level}.
#'
#' @inheritParams diff_print
#' @seealso \code{\link{diff_obj}} for details on output and diff algorithm,
#'   \code{\link{etc}} for more detailed control of diff settings,
#'   \code{\link{diff_print}},
#'   \code{\link{diff_chr}} to compare character vectors directly,
#'   \code{\link{diff_deparse}} to compare deparsed objects
#' @return a \code{\link{diffObjDiff}} object; this object has a \code{show}
#'   method that will display the diff to screen
#' @export

diff_str <- make_diff_fun(capt_str)

#' Diff Character Vectors Element By Element
#'
#' Will perform the diff on the actual string values of the character vectors
#' without displaying to screen and capturing.  Each vector element is treated
#' as a line of text.
#'
#' @inheritParams diff_print
#' @seealso \code{\link{diff_obj}} for details on output and diff algorithm,
#'   \code{\link{etc}} for more detailed control of diff settings,
#'   \code{\link{diff_print}}, \code{\link{diff_str}},
#'   \code{\link{diff_deparse}} to compare deparsed objects
#' @return a \code{\link{diffObjDiff}} object; this object has a \code{show}
#'   method that will display the diff to screen
#' @export
#' @examples
#' diff_chr(LETTERS[1:5], LETTERS[2:6])

diff_chr <- make_diff_fun(capt_chr)

#' @rdname diff_obj
#' @export

diff_deparse <- make_diff_fun(capt_deparse)

#' Diff Objects
#'
#' Compare either the \code{print}ed or \code{str} screen representation of
#' R objects depending on which is estimated to produce the most useful
#' diff.  The selection process tries to minimize screen lines while maximizing
#' differences shown subject to display constraints.  The decision algorithm is
#' likely to evolve over time, so do not rely on this function making a
#' a particular selection under specific circumstances.  Instead, use
#' \code{\link{diff_print}} or \code{\link{diff_str}} if you require one or the
#' other output.
#'
#' @section Output:
#'
#' The result of the diff provides the information necessary to transform the
#' \code{target} object into the \code{current} object.  This involves deletions
#' from and additions to \code{target}.  The deletions and additions are done
#' linewise.  Each deleted line will have \code{- } prepended to it, and each
#' added line will have \code{+ } prepended to it.  If your terminal supports
#' ANSI escape sequences the additions and deletions will be color coded.
#'
#' The first lines of output clarify the coding convention by showing the
#' \code{target} object with the deletion symbology, and the \code{current}
#' object with the addition symbology.  After these lines you will see the
#' first and possibly only hunk header.  The format will be \code{@@ x,y z,w @@}
#' where \code{x} and \code{z} indicate the starting line of the text in
#' the \code{target} and \code{current} objects that is shown after the hunk
#' header.  \code{y} and \code{w} indicate how many lines from each of those
#' objects are being shown.
#'
#' In addition to the primary line diff, hunks are themselves word-diffed within
#' each hunk to help quickly identify small differences.  Just keep in mind that
#' the \code{+-} symbols always relate to the original line diff.  The
#' word-diff is indicated only by the ANSI escape sequence styling and will not
#' be visible if your terminal does not support them or if you disable them.
#'
#' The output format used here is loosely based on the \code{git diff} format.
#'
#' @section Diff Algorithm:
#'
#' The diff algorithm is Myer's solution to the shortest edit script /
#' longest common sequence problem with the Hirschberg linear space refinement
#' as described in:
#' \cite{
#' E. Myers, \dQuote{An O(ND) Difference Algorithm and Its Variations},
#' Algorithmica 1, 2 (1986), 251-266.
#' \url{http://www.cs.arizona.edu/people/gene/PAPERS/diff.ps}
#' }
#' and should be the same algorithm used by GNU diff.  The implementation
#' used here is an adaptation of Michael B. Allen's diff program from the
#' \href{
#'    http://www.ioplex.com/~miallen/libmba/dl/libmba-0.9.1.tar.gz
#' }{\code{libmba}} \code{C} library.
#'
#' This algorithm scales with the \bold{square} of the number of differences
#' between compared objects so is most effective when comparing objects
#' that are mostly similar.
#'
#' @inheritParams diff_print
#' @seealso \code{\link{etc}} for more detailed control of diff settings,
#'   \code{\link{diff_print}}, \code{\link{diff_str}},
#'   \code{\link{diff_chr}} to compare character vectors directly,
#'   \code{\link{diff_deparse}} to compare deparsed objects
#' @return a \code{\link{diffObjDiff}} object; this object has a \code{show}
#'   method that will display the diff to screen
#' @export

diff_obj <- diff_print # we overwrite the body next

body(diff_obj) <- quote({
  if(length(list(...))) {
    stop("`...` argument not supported in `diff_obj`")
  }
  call.raw <- match.call()
  call.raw[["silent"]] <- TRUE
  call.str <- call.print <- call.raw
  call.str[[1L]] <- quote(diff_str)
  call.str[["max.level"]] <- "auto"
  call.print[[1L]] <- quote(diff_print)

  # Run both the print and str versions, and then decide which to use based
  # on some weighting of various factors including how many lines needed to be
  # omitted vs. how many differences were reported

  res.print <- eval(call.print, parent.frame())
  res.str <- eval(call.str, parent.frame())

  diff.p <- count_diffs(res.print@diffs$hunks)
  diff.s <- count_diffs(res.str@diffs$hunks)

  # Only show the one with differences

  res <- if(!diff.s && diff.p) {
    res.print
  } else if(!diff.p && diff.s) {
    res.str

  # If one fits in full and the other doesn't, show the one that fits in full
  } else if(
    !res.str@trim.dat$lines[[1L]] &&
    res.print@trim.dat$lines[[1L]]
  ) {
    res.str
  } else if(
    res.str@trim.dat$lines[[1L]] &&
    !res.print@trim.dat$lines[[1L]]
  ) {
    res.print
  # Calculate the trade offs between the two options
  } else {
    s.score <- with(res.str@trim.dat, {
      diff(lines) - lines[[1L]] + diff(diffs)
    })
    p.score <- with(res.print@trim.dat, {
      diff(lines) - .5 * lines[[1L]] + diff(diffs)
    })
    if(p.score >= s.score) res.print else res.str
  }
  res
})
